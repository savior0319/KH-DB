/*

패키지 

1. ID값을 입력하면 특정 정보(사번, 이름, 주민번호, 폰 번호)를 출력하는 프로시저를 생성
2. 사번 값을 입력하면 보너스값을 리턴하는 함수를 생성

이 때 프로시저와 함수를 묶는 패키지를 만들어라
*/

CREATE PACKAGE EMP_PACK 
IS 
  PROCEDURE SELECT_USER(ID  EMP.EMP_ID%TYPE);
  FUNCTION BONUS_RETURN(ID EMP.EMP_ID%TYPE) 
  RETURN NUMBER;
END;
/

CREATE OR REPLACE PACKAGE BODY EMP_PACK
IS
  PROCEDURE SELECT_USER(ID EMP.EMP_ID%TYPE)
IS 
    E_ID EMP.EMP_ID%TYPE;
    E_NAME EMP.EMP_NAME%TYPE;
    E_NO EMP.EMP_NO%TYPE;
    E_PHONE EMP.PHONE%TYPE;
BEGIN
    SELECT EMP_ID, EMP_NAME, EMP_NO, PHONE
    INTO E_ID, E_NAME, E_NO, E_PHONE
    FROM EMP
    WHERE EMP_ID = ID;
    DBMS_OUTPUT.PUT_LINE('사원번호 -> ' || E_ID);
    DBMS_OUTPUT.PUT_LINE('사원이름 -> ' || E_NAME);
    DBMS_OUTPUT.PUT_LINE('주민번호 -> ' || E_NO);
    DBMS_OUTPUT.PUT_LINE('전화번호 -> ' || E_PHONE);
END;
FUNCTION BONUS_RETURN(ID EMP.EMP_ID%TYPE)
RETURN NUMBER
IS
    E_BONUS EMP.BONUS%TYPE;
    E_SALARY EMP.SALARY%TYPE;
    SAL NUMBER;
BEGIN
    SELECT SALARY, NVL(BONUS, 0)
    INTO E_SALARY, E_BONUS
    FROM EMP
    WHERE EMP_ID = ID;
    SAL := E_SALARY * E_BONUS;
    RETURN SAL;
END;
END;
/

EXEC EMP_PACK.SELECT_USER(201);
SELECT EMP_PACK.BONUS_RETURN(204) FROM DUAL;


/*
트리거 실습을 위한 테이블 2개 생성
회원 테이블, 탈퇴 회원 테이블
*/
CREATE TABLE M_TBL(
  USER_ID VARCHAR2(20) PRIMARY KEY,
  USERPWD VARCHAR(20) NOT NULL,
  USERNAME VARCHAR(20) NOT NULL,
  ENROLL_DATE DATE
);

CREATE TABLE DEL_M_TBL(
  USERID VARCHAR2(20) PRIMARY KEY,
  USERNAME VARCHAR2(20),
  ENROLL_DATE DATE,
  OUT_DATE DATE
);

/* 테스트 데이터 삽입 */
INSERT INTO M_TBL
VALUES('USER11', 'PASS11', '노민수', '16/05/23');
INSERT INTO M_TBL
VALUES('USER22', 'PASS22', '한아름', '17/05/03');
INSERT INTO M_TBL
VALUES('USER33', 'PASS33', '황누리', '17/04/13');
INSERT INTO M_TBL
VALUES('USER44', 'PASS44', '한영진', '15/04/27');


/* PL/SQL을 이용한 삭제 */
DECLARE
  ID M_TBL.USER_ID%TYPE;
  NAME M_TBL.USERNAME%TYPE;
  ENDATE M_TBL.ENROLL_DATE%TYPE;
BEGIN
  SELECT USER_ID, USERNAME, ENROLL_DATE
  INTO ID, NAME, ENDATE
  FROM M_TBL
  WHERE USER_ID = 'USER22';
  INSERT INTO DEL_M_TBL
  VALUES(ID, NAME, ENDATE, SYSDATE);
  DELETE FROM M_TBL
  WHERE USER_ID = 'USER22';
END;
/

/*
트리거를 이용한 방법
*/

CREATE OR REPLACE TRIGGER M_TBL_TRG
AFTER DELETE 
ON M_TBL
FOR EACH ROW
BEGIN
  INSERT INTO DEL_M_TBL VALUES
  (:OLD.USER_ID, :OLD.USERNAME, :OLD.ENROLL_DATE, SYSDATE);
END;
/

/* 삭제 */
DELETE FROM M_TBL
WHERE USER_ID LIKE 'USER22';

/* 조회 -> M_TBL에서 삭제한 정보가 DEL_M_TBL에 삽입 */
SELECT * FROM M_TBL;
SELECT * FROM DEL_M_TBL;

/* */
CREATE OR REPLACE TRIGGER TRIG_EMP_SAL
  BEFORE
  UPDATE ON TBL_EMP_SALARY
  REFERENCING NEW AS NEW_EMP_REC OLD AS OLD_EMP_REC
  FOR EACH ROW
BEGIN
  DBMS_OUTPUT.PUT_LINE('변경전 : ' || :OLD_EMP_REC.SALARY);
  DBMS_OUTPUT.PUT_LINE('변경후 : ' || :NEW_EMP_REC.SALARY);
END;
/


/* INSERT 시 메세지 트리거 */
INSERT INTO M_TBL VALUES('KH', 'KH11', '케이', '16/01/01');

/* 트리거 생성*/
CREATE OR REPLACE TRIGGER M_TBL_INSERT_TRG
AFTER INSERT
ON M_TBL
FOR EACH ROW
BEGIN
  DBMS_OUTPUT.PUT_LINE(:NEW.USERNAME || '님이 신규가입 했습니다');
END;
/

/*
간단 실습 
N_TBL 에서 회원 정보 (이름 변경시 LOG_TBL에 기록 남기기)
-> LOG_TBL 컬럼 (유저ID, 로그 내용, 날짜)
  ※ 유저 ID : 로그가 남는 유저 ID
  ※ 로그내용 :  변경 전 이름 -> 변경 후 이름
  ※ 날짜 : 실행한 시간
*/

/* 테이블 생성 */
CREATE TABLE LOG_TBL(
USER_ID VARCHAR2(20),
CONTENT VARCHAR2(100),
TIME DATE
);



/* 트리거 생성 */
CREATE OR REPLACE TRIGGER NAME_CNG_TRG
AFTER UPDATE
ON M_TBL
FOR EACH ROW
BEGIN
  INSERT INTO LOG_TBL VALUES
  (:OLD.USER_ID, :OLD.USERNAME || '->' || :NEW.USERNAME, SYSDATE);
END;
/

/* 이름 수정 노민수 -> 바꾼이름 */
UPDATE M_TBL
SET USERNAME = '바꾼이름'
WHERE USER_ID = 'USER11';

UPDATE M_TBL
SET USERNAME = '노민수'
WHERE USER_ID = 'USER11';

/* 로그 테이블 조회 */
SELECT *
FROM LOG_TBL;

/*
제품이 입고 될 때 마다 상품 재고 테이블의 수치를 자동으로 변경되는 트리거 만들기
(입, 출고 될 때마다 관리자가 수동으로 수치를 조정하면 불편하고 일이 많아짐)

2개의 테이블 

1. 제품 및 재고 테이블
2. 입출고 테이블
*/

CREATE TABLE PRODUCT(
  PCODE NUMBER PRIMARY KEY,
  PNAME VARCHAR2(30),
  BRAND VARCHAR2(30),
  PRICE NUMBER,
  STOCK NUMBER DEFAULT 0
);

CREATE TABLE PRO_DETAIL(
  DCODE NUMBER PRIMARY KEY,
  PCODE NUMBER,
  PDATE DATE,
  AMOUNT NUMBER,
  STATUS VARCHAR2(10) CHECK (STATUS IN('입고', '출고')),
  FOREIGN KEY (PCODE) REFERENCES PRODUCT(PCODE)
);

INSERT INTO PRODUCT
VALUES(1111, '칸쵸', '롯데', 1500, DEFAULT);

INSERT INTO PRODUCT
VALUES(2222, '시리얼', '롯데', 3000, DEFAULT);

INSERT INTO PRODUCT
VALUES(3333, '허니버터칩', '해태', 10000, DEFAULT);

INSERT INTO PRODUCT
VALUES(4444, '꼬북칩', '오리온', 1000, DEFAULT);

CREATE SEQUENCE INNUM
START WITH 1
INCREMENT BY 1
MAXVALUE 10000
NOCYCLE
NOCACHE;

INSERT INTO PRO_DETAIL
VALUES(INNUM.NEXTVAL, 1111, SYSDATE, 5, '입고');

UPDATE PRODUCT
SET STOCK = STOCK + 5
WHERE PCODE = 1111;

/*
트리거를 사용해서 입,출고 내역에 따라 재고수량이 자동으로 변경되도록 만듦
*/
CREATE OR REPLACE TRIGGER PRO_TRG
AFTER INSERT
ON PRO_DETAIL
FOR EACH ROW
BEGIN
  IF(:NEW.STATUS LIKE '입고')
  THEN
    UPDATE PRODUCT
    SET STOCK = STOCK + :NEW.AMOUNT
    WHERE PCODE = :NEW.PCODE;
  ELSIF(:NEW.STATUS LIKE '출고')
  THEN
    UPDATE PRODUCT
    SET STOCK = STOCK - :NEW.AMOUNT
    WHERE PCODE = :NEW.PCODE;
  END IF;
END;
/

/* 입고 */
INSERT INTO PRO_DETAIL
VALUES(INNUM.NEXTVAL, 1111, SYSDATE, 7, '입고');

/* 출고 */
INSERT INTO PRO_DETAIL
VALUES(INNUM.NEXTVAL, 1111, SYSDATE, 3, '출고');

SELECT *
FROM PRODUCT;

SELECT *
FROM PRO_DETAIL;




