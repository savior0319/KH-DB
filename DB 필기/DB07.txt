
 @ DDL
 -> 데이터 정의 언어
 -> 객체를 만들고 CREATE, ALTER, DROP하는 구문

 @ 오라클 객체의 종류
 테이블 뷰 시퀸스 인덱스 패키지 프로시져 함수 트리거 동의어 사용자가 있음

 @ CREATE 테이블 만들기

  표현식
  ORACLE TABLE 테이블명(컬럼명 자료형(크기), 컬럼명 자료형(크기), ...);

  ex)
  CREATE TABLE MEMBER(
  MEMBER_ID VARCHAR2(20),
  MEMBER_PWD VARCHAR2(20),
  MEMBER_NAME VARCHAR2(20)
  )


  @ 컬럼 주석

  ex)
  /* 컬럼 주석 */
  COMMENT ON COLUMN MEMBER.MEMBER_ID IS
  '회원아이디';
  COMMENT ON COLUMN MEMBER.MEMBER_PWD IS
  '회원비빌번호';
  COMMENT ON COLUMN MEMBER.MEMBER_NAME IS
  '회원이름';

  @ 제약 조건 (CONSTRAINTS)
  -> 테이블 작성 시 (생성 시) 각 컬럼에 대한 제약 조건을 설정 할 수 있음
  -> 데이터 무결성을 지키기 위해 제한된 조건
      -> 데이터 무결성 : 데이터의 정확성과 일관성을 유지하기 위한 것

  NOT NULL : 데이터에 NULL을 허용하지 않음
  UNIQUE : 중복된 값을 허용하지 않음
  PRIMARY KEY : NULL을 허용하지 않고 중복 값을 허용하지 않음
  FOREIGN KEY : 두 테이블의 데이터간 연결을 설정하고 강제 적용하여 외래키 테이블에 저장될 수 있는 데이터를 제어함
  CHECK : 저장 가능한 데이터 값의 범위나 조건을 지정하여 설정한 값만 허용 함


  @ 제약 조건 정보 확인

  SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS
  WHERE TABLE_NAME = '테이블명';

  ※ CONSTRAINT_TYPE
      P : PRIMARY KEY
      R : FOREIGN KEY
      C : CHECK 또는 NOT NULL
      U : UNIQUE

  ex)
    /* 테이블 제약조건 확인 */
    SELECT TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME
    FROM USER_CONS_COLUMNS
    WHERE TABLE_NAME = 'USER_NOTCONS'
    UNION
    SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE
    FROM USER_CONSTRAINTS
    WHERE TABLE_NAME = 'USER_NOTCONS';

  @ NOT NULL
  -> 해당 컬럼에 반드시 값이 기록되어야 하는 경우, 특정 컬럼에 값을 저장하거나 수정할 때
  NULL 값을 허용하지 않도록 컬럼 레벨에서 제한함

  ## 테이블 생성 시 제약조건을 설정하지 않고 생성

    CREATE TABLE USER_NOTCONS
    (
      USER_NO NUMBER,
      USER_ID VARCHAR2(20),
      USER_PWD VARCHAR2(30),
      USER_NAME VARCHAR2(30),
      GENDER VARCHAR2(30),
      PHONE VARCHAR2(30),
      EMAIL VARCHAR2(50)
    );

  -> 아무런 제약조건이 명시 되지 않으면 제한 없는 데이터 혹은 데이터를 넣지 않고도 INSERT가 가능해짐

  ※ INSERT INTO USER_NOTCONS
    VALUES(1, NULL, NULL, NULL, NULL, NULL, NULL);

    ex) NOT NULL 제약조건
    /* USER_NOTCONS 테이블 생성 (NOT NULL 제약조건)*/
    CREATE TABLE USER_NOTCONS
    (
      USER_NO NUMBER NOT NULL,
      USER_ID VARCHAR2(20) NOT NULL,
      USER_PWD VARCHAR2(30) NOT NULL,
      USER_NAME VARCHAR2(30) NOT NULL,
      GENDER VARCHAR2(30) NOT NULL,
      PHONE VARCHAR2(30) NOT NULL,
      EMAIL VARCHAR2(50)  NOT NULL
    );

    ※ NOT NULL 제약조건이 있는 컬럼에 NULL 데이터 삽입 시 오류 발생

    @ UNIQUE
    -> 컬럼 입력 값에 대해 중복을 제한하는 제약 조건
    -> 컬럼 레벨과 테이블 레벨에 설정 가능

    ## 제약 조건 설정 ##
    ex)
    /* USER_NOTCONS 테이블 생성 (NOT NULL, UNIQUE(USER_ID) (컬럼레벨) 제약조건)*/
    CREATE TABLE USER_NOTCONS
    (
      USER_NO NUMBER NOT NULL,
      USER_ID VARCHAR2(20) NOT NULL UNIQUE,
      USER_PWD VARCHAR2(30) NOT NULL,
      USER_NAME VARCHAR2(30) NOT NULL,
      GENDER VARCHAR2(30) NOT NULL,
      PHONE VARCHAR2(30) NOT NULL,
      EMAIL VARCHAR2(50)  NOT NULL
    );
S
    /* USER_NOTCONS 테이블 생성 (NOT NULL, UNIQUE(USER_ID) (테이블 레벨 설정)제약조건)*/
    CREATE TABLE USER_NOTCONS
    (
      USER_NO NUMBER NOT NULL,
      USER_ID VARCHAR2(20) NOT NULL,
      USER_PWD VARCHAR2(30) NOT NULL,
      USER_NAME VARCHAR2(30) NOT NULL,
      GENDER VARCHAR2(30) NOT NULL,
      PHONE VARCHAR2(30) NOT NULL,
      EMAIL VARCHAR2(50)  NOT NULL,
      UNIQUE(USER_ID)
    );

    -> UNIQUE 제약 조건이 설정되면 중복된 데이터를 넣을 수 없음
    -> 하지만 UNIQUE 제약 조건이 설정되었다 하더라도 NULL 값으로 넣게 되면
    데이터가 처리 되어 버림
    -> 해결 방법은 UNIQUE 제약조건과 NOT NULL 제약 조건을 동시에 주는 방법
    혹은 PRIMARY KEY로 설정하는 방법이 있음


    @ PRIMARY KEY
    -> 테이블에서 한 행의 정보를 구별하기 위해 사용하는 고유 식별자 (IDENTIFIER)
    -> NOT NULL 제약조건과 UNIQUE 제약 조건의 의미를 둘 다 가지고 있으며,
    한 테이블당 한개만 설정 가능
    -> 컬럼 레벨, 테이블 레벨에서 지정 가능

    ## PRIMARY KEY - 컬럼 레벨에서 설정
    ex)
      CREATE TABLE USER_NOTCONS
      (
        USER_NO NUMBER PRIMARY KEY,
        USER_ID VARCHAR2(20) UNIQUE,
        USER_PWD VARCHAR2(30) NOT NULL,
        USER_NAME VARCHAR2(30) NOT NULL,
        GENDER VARCHAR2(30) NOT NULL,
        PHONE VARCHAR2(30) NOT NULL,
        EMAIL VARCHAR2(50)  NOT NULL
      );

    ## PRIMARY KEY - 테이블 레벨에서 설정
    ex)
      CREATE TABLE USER_NOTCONS
      (
        USER_NO NUMBER,
        USER_ID VARCHAR2(20) UNIQUE,
        USER_PWD VARCHAR2(30) NOT NULL,
        USER_NAME VARCHAR2(30) NOT NULL,
        GENDER VARCHAR2(30) NOT NULL,
        PHONE VARCHAR2(30) NOT NULL,
        EMAIL VARCHAR2(50)  NOT NULL,
        PRIMARY KEY(USER_NO)
      );

      @ CHECK
      -> 해당 컬럼에 입력되거나 수정되는 값을 체크하여, 설정된 값 이외의 값이면
      에러를 발생
      -> 비교 연산자를 이용하여 조건을 설정할 수 있으며, 비교 값은 리터럴만 사용가능하고 값이 변하는 형태는
      사용 불가능

      ## CHECK 제약조건을 이용하여 GENDER 'M', 'F' 만 가능하게 설정
          -> CHECK 제약조건을 자동으로 NOT NULL 제약조건 ('M', 'F'만 가능하므로)

      ex)
      /* CHECK 제약조건 (GENDER = 'M' OR 'F') */
      CREATE TABLE USER_NOTCONS
      (
            USER_NO NUMBER,
            USER_ID VARCHAR2(20) UNIQUE,
            USER_PWD VARCHAR2(30) NOT NULL,
            USER_NAME VARCHAR2(30) NOT NULL,
            GENDER VARCHAR2(30) CHECK (GENDER IN('F', 'M')),
            PHONE VARCHAR2(30) NOT NULL,
            EMAIL VARCHAR2(50)  NOT NULL,
            PRIMARY KEY(USER_NO)
      );

    -> GENDER 값에  'M', 'F' 만 가능 함
      INSERT INTO USER_NOTCONS
      VALUES(1, 'USER1', 'P@SSw0RD', '이름', 'F', '10-0000-0000', 'EMAIL@EMAIL.MAIL');

      INSERT INTO USER_NOTCONS
      VALUES(2, 'USER2', 'P@SSw0RD', '이름', 'M', '10-0000-0000', 'EMAIL@EMAIL.MAIL');


  @ FOREIGN KEY (외래키)
  -> 참조 무결성을 유지하기 위한 제약 조건
  -> 참조된 다른 테이블이 제공하는 값만 사용할 수 있도록 제한을 거는것
  -> 참조되는 컬럼과 참조된 컬럼을 통해 테이블간의 관계가 형성 됨
  -> 해당 컬럼 값은 참조되는 테이블의 컬럼 값 중의 하나와 일치하거나
    NULL을 가질 수 있음
  -> 일반적으로 참조되는 테이블에서 고유 식별할 수 있는 기본키를 외래키로 사용할 수 있음
    (꼭 기본키로만 설정하는 것은 아님!!)
